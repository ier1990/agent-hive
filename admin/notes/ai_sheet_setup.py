#!/usr/bin/env python3
"""ai_sheet_setup.py

Creates/updates AI_SHEET.md for a chosen PHP target version (default: 7.3)
AND can scan a codebase for common incompatibilities (heuristic).

Usage:
  ./ai_sheet_setup.py --target 7.3 --write-sheet
  ./ai_sheet_setup.py --target 7.3 --scan --root /web/html
  ./ai_sheet_setup.py --target 7.3 --write-sheet --scan --root /web/html

Notes:
- The scan is grep/regex-based. It is NOT a PHP parser.
- It is intentionally conservative: it reports likely issues; you verify/fix.
"""

import argparse
import os
import re
import sys
from dataclasses import dataclass
from typing import Dict, Iterable, List, Optional, Tuple


@dataclass
class Finding:
    file_path: str
    line_no: int
    rule_id: str
    message: str
    line: str


@dataclass
class ScanRule:
    rule_id: str
    rx: re.Pattern
    message: str
    min_strictness: int


def _iter_php_files(root: str) -> Iterable[str]:
    for base, dirs, files in os.walk(root):
        # Skip typical noise
        dirs[:] = [d for d in dirs if d not in {".git", "node_modules", "vendor", "__pycache__"}]
        for name in files:
            if name.lower().endswith(".php"):
                yield os.path.join(base, name)


def _read_lines(path: str) -> List[str]:
    # Best-effort decoding. We only need to scan tokens.
    with open(path, "rb") as f:
        raw = f.read()
    try:
        text = raw.decode("utf-8")
    except UnicodeDecodeError:
        text = raw.decode("latin-1", errors="replace")
    return text.splitlines()


def _version_tuple(v: str) -> Tuple[int, int]:
    parts = v.strip().split(".")
    if len(parts) < 2:
        raise ValueError(f"Invalid version: {v!r} (expected like 7.3)")
    return int(parts[0]), int(parts[1])


def _sheet_markdown(target: str) -> str:
    return f"""# AI Sheet: PHP Compatibility (Target {target})

Generated by `ai_sheet_setup.py`.

## Target

- **PHP version:** {target}
- **Goal:** All pages should run without fatal errors on PHP {target}.

## Allowed language features (safe on 7.3)

- Scalar + nullable type hints: `function f(?string $x): ?int`
- Null coalescing: `$x = $_GET['x'] ?? ''`
- Short array syntax: `[]`
- `Throwable` / `Exception`

## Avoid (common breakages when targeting 7.3)

- Typed properties (`public int $x;`) (PHP 7.4+)
- Arrow functions (`fn($x) => ...`) (PHP 7.4+)
- Nullsafe operator (`$a?->b`) (PHP 8.0+)
- `match` expressions (PHP 8.0+)
- Union types (`int|string`) (PHP 8.0+)
- Named arguments (PHP 8.0+)
- Constructor property promotion (PHP 8.0+)
- `str_starts_with`, `str_ends_with`, `str_contains` (PHP 8.0+)

## Reliability rules

- Never hard-`exit` on missing directories (except deliberate access-control blocks).
- Prefer collecting errors and rendering them in the UI so a fresh install can self-diagnose.
- When creating directories, handle failure and include a fix command.

## Filesystem expectations

Common writable dirs for SQLite + uploads:

- `/web/private/db/memory/`
- `/web/private/uploads/memory/`

Recommended fix commands:

```bash
sudo mkdir -p /web/private/db/memory /web/private/uploads/memory
sudo chown -R www-data:www-data /web/private/db/memory /web/private/uploads/memory
sudo chmod 775 /web/private/db/memory /web/private/uploads/memory
```

## Bash History Ingest (Hourly) DB Schema

The hourly ingest script is:

- `/web/html/admin/notes/scripts/ingest_bash_history_to_kb.py`

It writes to:

- **KB DB:** `/web/private/db/memory/bash_history.db`
- **State DB:** `/web/private/db/memory/human_notes.db` (table: `history_state`)

### `bash_history.db`

```sql
CREATE TABLE IF NOT EXISTS commands (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    full_cmd TEXT NOT NULL UNIQUE,
    base_cmd TEXT NOT NULL,
    first_seen TEXT DEFAULT (datetime('now')),
    last_seen  TEXT DEFAULT (datetime('now')),
    seen_count INTEGER DEFAULT 1
);
CREATE INDEX IF NOT EXISTS idx_commands_base_cmd ON commands(base_cmd);

CREATE TABLE IF NOT EXISTS command_ai (
    cmd_id INTEGER PRIMARY KEY,
    status TEXT DEFAULT 'pending',
    model TEXT,
    prompt_version TEXT,
    result_json TEXT,
    summary TEXT,
    search_query TEXT,
    known INTEGER DEFAULT 0,
    updated_at TEXT DEFAULT (datetime('now')),
    last_error TEXT
);
CREATE INDEX IF NOT EXISTS idx_command_ai_status ON command_ai(status, updated_at);

CREATE TABLE IF NOT EXISTS base_commands (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    base_cmd TEXT NOT NULL UNIQUE,
    first_seen TEXT DEFAULT (datetime('now')),
    last_seen  TEXT DEFAULT (datetime('now')),
    seen_count INTEGER DEFAULT 1
);

CREATE TABLE IF NOT EXISTS enrich_queue (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    kind TEXT NOT NULL,
    ref TEXT NOT NULL,
    status TEXT DEFAULT 'pending',
    priority INTEGER DEFAULT 100,
    attempts INTEGER DEFAULT 0,
    last_error TEXT,
    created_at TEXT DEFAULT (datetime('now')),
    updated_at TEXT DEFAULT (datetime('now')),
    UNIQUE(kind, ref)
);
CREATE INDEX IF NOT EXISTS idx_queue_status_priority ON enrich_queue(status, priority, created_at);
```

### `human_notes.db` state table

```sql
CREATE TABLE IF NOT EXISTS history_state (
    host TEXT NOT NULL,
    path TEXT NOT NULL,
    inode TEXT,
    last_line INTEGER DEFAULT 0,
    updated_at TEXT,
    PRIMARY KEY (host, path)
);
```

## Quick checks

- Syntax check: `php -l path/to/file.php`
- Scan for incompatibilities (heuristic): `./ai_sheet_setup.py --target {target} --scan --root /web/html`
"""


def scan_for_php73_issues(root: str, strictness: int) -> List[Finding]:
    findings: List[Finding] = []

    strictness = max(0, min(5, int(strictness)))

    # Heuristic rules are grep/regex-based and intentionally imperfect.
    # strictness 0: off (useful when you only want sheet generation)
    # strictness 1-2: high-confidence, lower noise
    # strictness 3: recommended repo scan default
    # strictness 4-5: more aggressive / more false positives
    all_rules: List[ScanRule] = [
        ScanRule(
            "PHP74_ARROW_FN",
            re.compile(r"\bfn\s*\("),
            "Arrow functions require PHP 7.4+",
            1,
        ),
        ScanRule(
            "PHP74_COALESCE_ASSIGN",
            re.compile(r"\?\?="),
            "Null coalescing assignment (??=) requires PHP 7.4+",
            1,
        ),
        ScanRule(
            "PHP74_ARRAY_UNPACK",
            re.compile(r"\[[^\]]*\.{3}\s*\$"),
            "Array unpacking in array literals ([...$x]) requires PHP 7.4+",
            1,
        ),
        ScanRule(
            "PHP80_MATCH",
            re.compile(r"\bmatch\s*\("),
            "match expressions require PHP 8.0+",
            1,
        ),
        ScanRule(
            "PHP80_NULLSAFE",
            re.compile(r"\?->"),
            "Nullsafe operator requires PHP 8.0+",
            1,
        ),
        ScanRule(
            "PHP80_STR_CONTAINS",
            re.compile(r"\bstr_(contains|starts_with|ends_with)\s*\("),
            "str_contains/starts_with/ends_with require PHP 8.0+",
            1,
        ),
        ScanRule(
            "PHP74_TYPED_PROP",
            re.compile(
                r"\b(public|protected|private)\s+(static\s+)?\??[A-Za-z_\\\\][A-Za-z0-9_\\\\]*\s+\$[A-Za-z_]\w*\s*[;=]"
            ),
            "Typed properties require PHP 7.4+",
            2,
        ),
        ScanRule(
            "PHP80_CTOR_PROMO",
            re.compile(r"\bfunction\s+__construct\s*\(.*\b(public|protected|private)\s+\$", re.IGNORECASE),
            "Constructor property promotion requires PHP 8.0+",
            2,
        ),
        ScanRule(
            "PHP80_UNION_TYPES",
            re.compile(
                r"\b(?:int|float|string|bool|array|callable|iterable|object|mixed|self|parent|\\\\?[A-Z][A-Za-z0-9_\\\\]*)\s*\|\s*(?:int|float|string|bool|array|callable|iterable|object|mixed|self|parent|\\\\?[A-Z][A-Za-z0-9_\\\\]*)\b"
            ),
            "Union types require PHP 8.0+",
            2,
        ),
        ScanRule(
            "PHP80_STATIC_RETURN",
            re.compile(r"\)\s*:\s*static\b"),
            "static return types require PHP 8.0+",
            3,
        ),
        ScanRule(
            "PHP80_ATTRS",
            re.compile(r"#\["),
            "Attributes (#[]) require PHP 8.0+",
            3,
        ),
        ScanRule(
            "PHP81_ENUM",
            re.compile(r"\benum\s+[A-Za-z_]"),
            "Enums require PHP 8.1+",
            3,
        ),
        ScanRule(
            "PHP81_READONLY",
            re.compile(r"\breadonly\b"),
            "readonly requires PHP 8.1+",
            3,
        ),
        ScanRule(
            "PHP80_THROW_EXPR",
            re.compile(r"\?\?\s*throw\b"),
            "throw as an expression (e.g. ?? throw) requires PHP 8.0+",
            3,
        ),
        ScanRule(
            "PHP80_NAMED_ARGS",
            re.compile(r"\([^\)]*\b[A-Za-z_]\w*\s*:\s*[^\)]+\)"),
            "Named arguments require PHP 8.0+ (heuristic; may false-positive)",
            4,
        ),
        ScanRule(
            "PHP80_MIXED_TYPE",
            re.compile(r"\)\s*:\s*mixed\b|\bfunction\b[^\n]*\bmixed\b"),
            "mixed type requires PHP 8.0+ (heuristic)",
            5,
        ),
    ]

    if strictness <= 0:
        return findings

    rules = [r for r in all_rules if r.min_strictness <= strictness]

    for path in _iter_php_files(root):
        try:
            lines = _read_lines(path)
        except OSError as e:
            findings.append(Finding(path, 0, "READ_ERROR", str(e), ""))
            continue

        for i, line in enumerate(lines, start=1):
            # Skip commented-only lines quickly
            stripped = line.strip()
            if not stripped or stripped.startswith("//"):
                continue

            for rule in rules:
                if rule.rx.search(line):
                    findings.append(Finding(path, i, rule.rule_id, rule.message, line.rstrip("\n")))

    return findings


def main(argv: Optional[List[str]] = None) -> int:
    p = argparse.ArgumentParser()
    p.add_argument("--target", default="7.3", help="Target PHP version, e.g. 7.3")
    p.add_argument("--write-sheet", action="store_true", help="Write/update AI_SHEET.md in this directory")
    p.add_argument("--scan", action="store_true", help="Scan for likely incompatibilities")
    p.add_argument("--root", default=os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..")), help="Root directory to scan")
    p.add_argument("--strictness", type=int, default=3, help="Scan strictness 0-5 (0=off, 3=recommended)")

    args = p.parse_args(argv)

    try:
        major, minor = _version_tuple(args.target)
    except ValueError as e:
        print(f"error: {e}", file=sys.stderr)
        return 2

    if (major, minor) != (7, 3):
        # Script currently contains rules tuned for 7.3.
        # We still allow writing the sheet for other versions.
        pass

    if args.write_sheet:
        out_path = os.path.join(os.path.dirname(__file__), "AI_SHEET.md")
        md = _sheet_markdown(args.target)
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(md)
        print(f"Wrote {out_path}")

    if args.scan:
        root = os.path.abspath(args.root)
        strictness = max(0, min(5, int(args.strictness)))
        print(f"Scanning PHP files under: {root}")
        print(f"Strictness: {strictness}")
        findings = scan_for_php73_issues(root, strictness)

        if not findings:
            print("No obvious PHP 7.3 incompatibilities found (heuristic scan).")
            return 0

        # Group by file for easier reading.
        by_file: Dict[str, List[Finding]] = {}
        for f in findings:
            by_file.setdefault(f.file_path, []).append(f)

        total = 0
        for path in sorted(by_file.keys()):
            items = sorted(by_file[path], key=lambda x: (x.line_no, x.rule_id))
            print(f"\n{path}")
            for it in items:
                total += 1
                loc = f"L{it.line_no}" if it.line_no else "L?"
                print(f"  {loc} {it.rule_id}: {it.message}")
                if it.line:
                    print(f"    {it.line.strip()}")

        print(f"\nFindings: {total}")

    if not args.write_sheet and not args.scan:
        p.print_help()

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
